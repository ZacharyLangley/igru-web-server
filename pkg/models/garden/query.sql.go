// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: query.sql

package garden

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createGarden = `-- name: CreateGarden :one
INSERT INTO gardens (
  name, group_id, comment, location, grow_type, grow_size, grow_style, container_size, tags, created_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10
)
RETURNING id, group_id, name, comment, location, grow_type, grow_size, grow_style, container_size, tags, created_at, updated_at
`

type CreateGardenParams struct {
	Name          string
	GroupID       pgtype.UUID
	Comment       string
	Location      string
	GrowType      string
	GrowSize      string
	GrowStyle     string
	ContainerSize string
	Tags          string
	CreatedAt     pgtype.Timestamp
}

func (q *Queries) CreateGarden(ctx context.Context, arg CreateGardenParams) (Garden, error) {
	row := q.db.QueryRow(ctx, createGarden,
		arg.Name,
		arg.GroupID,
		arg.Comment,
		arg.Location,
		arg.GrowType,
		arg.GrowSize,
		arg.GrowStyle,
		arg.ContainerSize,
		arg.Tags,
		arg.CreatedAt,
	)
	var i Garden
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.Comment,
		&i.Location,
		&i.GrowType,
		&i.GrowSize,
		&i.GrowStyle,
		&i.ContainerSize,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPlant = `-- name: CreatePlant :one
INSERT INTO plants (
  name, group_id, comment, notes, grow_cycle_length, parentage, origin, gender, days_flowering, days_cured, harvested_weight, bud_density, bud_pistils, tags, acquired_at, created_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, CURRENT_TIMESTAMP
)
RETURNING id, group_id, name, comment, notes, grow_cycle_length, parentage, origin, gender, days_flowering, days_cured, harvested_weight, bud_density, bud_pistils, tags, acquired_at, created_at, updated_at
`

type CreatePlantParams struct {
	Name            string
	GroupID         pgtype.UUID
	Comment         string
	Notes           string
	GrowCycleLength string
	Parentage       pgtype.UUID
	Origin          string
	Gender          string
	DaysFlowering   float64
	DaysCured       float64
	HarvestedWeight string
	BudDensity      float64
	BudPistils      bool
	Tags            string
	AcquiredAt      pgtype.Timestamp
}

func (q *Queries) CreatePlant(ctx context.Context, arg CreatePlantParams) (Plant, error) {
	row := q.db.QueryRow(ctx, createPlant,
		arg.Name,
		arg.GroupID,
		arg.Comment,
		arg.Notes,
		arg.GrowCycleLength,
		arg.Parentage,
		arg.Origin,
		arg.Gender,
		arg.DaysFlowering,
		arg.DaysCured,
		arg.HarvestedWeight,
		arg.BudDensity,
		arg.BudPistils,
		arg.Tags,
		arg.AcquiredAt,
	)
	var i Plant
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.Comment,
		&i.Notes,
		&i.GrowCycleLength,
		&i.Parentage,
		&i.Origin,
		&i.Gender,
		&i.DaysFlowering,
		&i.DaysCured,
		&i.HarvestedWeight,
		&i.BudDensity,
		&i.BudPistils,
		&i.Tags,
		&i.AcquiredAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createRecipe = `-- name: CreateRecipe :one
INSERT INTO recipes (
  name, group_id, comment, ingredients, instructions, ph, mix_time_milliseconds, tags, created_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING id, group_id, name, comment, ingredients, instructions, ph, mix_time_milliseconds, tags, created_at, updated_at
`

type CreateRecipeParams struct {
	Name                string
	GroupID             pgtype.UUID
	Comment             string
	Ingredients         string
	Instructions        string
	Ph                  float64
	MixTimeMilliseconds float64
	Tags                string
	CreatedAt           pgtype.Timestamp
}

func (q *Queries) CreateRecipe(ctx context.Context, arg CreateRecipeParams) (Recipe, error) {
	row := q.db.QueryRow(ctx, createRecipe,
		arg.Name,
		arg.GroupID,
		arg.Comment,
		arg.Ingredients,
		arg.Instructions,
		arg.Ph,
		arg.MixTimeMilliseconds,
		arg.Tags,
		arg.CreatedAt,
	)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.Comment,
		&i.Ingredients,
		&i.Instructions,
		&i.Ph,
		&i.MixTimeMilliseconds,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createStrain = `-- name: CreateStrain :one
INSERT INTO strains (
  name, group_id, comment, notes, type, price, thc_percent, cbd_percent, parentage, aroma, taste, tags, created_at
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING id, group_id, name, comment, notes, type, price, thc_percent, cbd_percent, parentage, aroma, taste, tags, created_at, updated_at
`

type CreateStrainParams struct {
	Name       string
	GroupID    pgtype.UUID
	Comment    string
	Notes      string
	Type       string
	Price      float64
	ThcPercent float64
	CbdPercent float64
	Parentage  pgtype.UUID
	Aroma      string
	Taste      string
	Tags       string
	CreatedAt  pgtype.Timestamp
}

func (q *Queries) CreateStrain(ctx context.Context, arg CreateStrainParams) (Strain, error) {
	row := q.db.QueryRow(ctx, createStrain,
		arg.Name,
		arg.GroupID,
		arg.Comment,
		arg.Notes,
		arg.Type,
		arg.Price,
		arg.ThcPercent,
		arg.CbdPercent,
		arg.Parentage,
		arg.Aroma,
		arg.Taste,
		arg.Tags,
		arg.CreatedAt,
	)
	var i Strain
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.Comment,
		&i.Notes,
		&i.Type,
		&i.Price,
		&i.ThcPercent,
		&i.CbdPercent,
		&i.Parentage,
		&i.Aroma,
		&i.Taste,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteGarden = `-- name: DeleteGarden :exec
DELETE FROM gardens
WHERE id = $1 AND group_id = $2
`

type DeleteGardenParams struct {
	ID      pgtype.UUID
	GroupID pgtype.UUID
}

func (q *Queries) DeleteGarden(ctx context.Context, arg DeleteGardenParams) error {
	_, err := q.db.Exec(ctx, deleteGarden, arg.ID, arg.GroupID)
	return err
}

const deletePlant = `-- name: DeletePlant :exec
DELETE FROM plants
WHERE id = $1 AND group_id = $2
`

type DeletePlantParams struct {
	ID      pgtype.UUID
	GroupID pgtype.UUID
}

func (q *Queries) DeletePlant(ctx context.Context, arg DeletePlantParams) error {
	_, err := q.db.Exec(ctx, deletePlant, arg.ID, arg.GroupID)
	return err
}

const deleteRecipe = `-- name: DeleteRecipe :exec
DELETE FROM recipes
WHERE id = $1 AND group_id = $2
`

type DeleteRecipeParams struct {
	ID      pgtype.UUID
	GroupID pgtype.UUID
}

func (q *Queries) DeleteRecipe(ctx context.Context, arg DeleteRecipeParams) error {
	_, err := q.db.Exec(ctx, deleteRecipe, arg.ID, arg.GroupID)
	return err
}

const deleteStrain = `-- name: DeleteStrain :exec
DELETE FROM strains
WHERE id = $1 AND group_id = $2
`

type DeleteStrainParams struct {
	ID      pgtype.UUID
	GroupID pgtype.UUID
}

func (q *Queries) DeleteStrain(ctx context.Context, arg DeleteStrainParams) error {
	_, err := q.db.Exec(ctx, deleteStrain, arg.ID, arg.GroupID)
	return err
}

const getGarden = `-- name: GetGarden :one
SELECT id, group_id, name, comment, location, grow_type, grow_size, grow_style, container_size, tags, created_at, updated_at FROM gardens
WHERE id = $1 AND group_id = $2 LIMIT 1
`

type GetGardenParams struct {
	ID      pgtype.UUID
	GroupID pgtype.UUID
}

func (q *Queries) GetGarden(ctx context.Context, arg GetGardenParams) (Garden, error) {
	row := q.db.QueryRow(ctx, getGarden, arg.ID, arg.GroupID)
	var i Garden
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.Comment,
		&i.Location,
		&i.GrowType,
		&i.GrowSize,
		&i.GrowStyle,
		&i.ContainerSize,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getGardens = `-- name: GetGardens :many
SELECT id, group_id, name, comment, location, grow_type, grow_size, grow_style, container_size, tags, created_at, updated_at FROM gardens
WHERE group_id = $1
`

func (q *Queries) GetGardens(ctx context.Context, groupID pgtype.UUID) ([]Garden, error) {
	rows, err := q.db.Query(ctx, getGardens, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Garden
	for rows.Next() {
		var i Garden
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Name,
			&i.Comment,
			&i.Location,
			&i.GrowType,
			&i.GrowSize,
			&i.GrowStyle,
			&i.ContainerSize,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPlant = `-- name: GetPlant :one
SELECT id, group_id, name, comment, notes, grow_cycle_length, parentage, origin, gender, days_flowering, days_cured, harvested_weight, bud_density, bud_pistils, tags, acquired_at, created_at, updated_at FROM plants
WHERE id = $1 AND group_id = $2 LIMIT 1
`

type GetPlantParams struct {
	ID      pgtype.UUID
	GroupID pgtype.UUID
}

func (q *Queries) GetPlant(ctx context.Context, arg GetPlantParams) (Plant, error) {
	row := q.db.QueryRow(ctx, getPlant, arg.ID, arg.GroupID)
	var i Plant
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.Comment,
		&i.Notes,
		&i.GrowCycleLength,
		&i.Parentage,
		&i.Origin,
		&i.Gender,
		&i.DaysFlowering,
		&i.DaysCured,
		&i.HarvestedWeight,
		&i.BudDensity,
		&i.BudPistils,
		&i.Tags,
		&i.AcquiredAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPlants = `-- name: GetPlants :many
SELECT id, group_id, name, comment, notes, grow_cycle_length, parentage, origin, gender, days_flowering, days_cured, harvested_weight, bud_density, bud_pistils, tags, acquired_at, created_at, updated_at FROM plants
WHERE group_id = $1
`

func (q *Queries) GetPlants(ctx context.Context, groupID pgtype.UUID) ([]Plant, error) {
	rows, err := q.db.Query(ctx, getPlants, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Plant
	for rows.Next() {
		var i Plant
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Name,
			&i.Comment,
			&i.Notes,
			&i.GrowCycleLength,
			&i.Parentage,
			&i.Origin,
			&i.Gender,
			&i.DaysFlowering,
			&i.DaysCured,
			&i.HarvestedWeight,
			&i.BudDensity,
			&i.BudPistils,
			&i.Tags,
			&i.AcquiredAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getRecipe = `-- name: GetRecipe :one
SELECT id, group_id, name, comment, ingredients, instructions, ph, mix_time_milliseconds, tags, created_at, updated_at FROM recipes
WHERE id = $1 AND group_id = $2 LIMIT 1
`

type GetRecipeParams struct {
	ID      pgtype.UUID
	GroupID pgtype.UUID
}

func (q *Queries) GetRecipe(ctx context.Context, arg GetRecipeParams) (Recipe, error) {
	row := q.db.QueryRow(ctx, getRecipe, arg.ID, arg.GroupID)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.Comment,
		&i.Ingredients,
		&i.Instructions,
		&i.Ph,
		&i.MixTimeMilliseconds,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRecipes = `-- name: GetRecipes :many
SELECT id, group_id, name, comment, ingredients, instructions, ph, mix_time_milliseconds, tags, created_at, updated_at FROM recipes
WHERE group_id = $1
`

func (q *Queries) GetRecipes(ctx context.Context, groupID pgtype.UUID) ([]Recipe, error) {
	rows, err := q.db.Query(ctx, getRecipes, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Recipe
	for rows.Next() {
		var i Recipe
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Name,
			&i.Comment,
			&i.Ingredients,
			&i.Instructions,
			&i.Ph,
			&i.MixTimeMilliseconds,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getStrain = `-- name: GetStrain :one
SELECT id, group_id, name, comment, notes, type, price, thc_percent, cbd_percent, parentage, aroma, taste, tags, created_at, updated_at FROM strains
WHERE id = $1 AND group_id = $2 LIMIT 1
`

type GetStrainParams struct {
	ID      pgtype.UUID
	GroupID pgtype.UUID
}

func (q *Queries) GetStrain(ctx context.Context, arg GetStrainParams) (Strain, error) {
	row := q.db.QueryRow(ctx, getStrain, arg.ID, arg.GroupID)
	var i Strain
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.Comment,
		&i.Notes,
		&i.Type,
		&i.Price,
		&i.ThcPercent,
		&i.CbdPercent,
		&i.Parentage,
		&i.Aroma,
		&i.Taste,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getStrains = `-- name: GetStrains :many
SELECT id, group_id, name, comment, notes, type, price, thc_percent, cbd_percent, parentage, aroma, taste, tags, created_at, updated_at FROM strains
WHERE group_id = $1
`

func (q *Queries) GetStrains(ctx context.Context, groupID pgtype.UUID) ([]Strain, error) {
	rows, err := q.db.Query(ctx, getStrains, groupID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Strain
	for rows.Next() {
		var i Strain
		if err := rows.Scan(
			&i.ID,
			&i.GroupID,
			&i.Name,
			&i.Comment,
			&i.Notes,
			&i.Type,
			&i.Price,
			&i.ThcPercent,
			&i.CbdPercent,
			&i.Parentage,
			&i.Aroma,
			&i.Taste,
			&i.Tags,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateGarden = `-- name: UpdateGarden :one
UPDATE gardens
SET name = $3, comment= $4, location = $5, grow_type = $6, grow_size = $7, grow_style = $8, container_size = $9, tags = $10, created_at = $11, updated_at=CURRENT_TIMESTAMP
WHERE id = $1 AND group_id = $2
RETURNING id, group_id, name, comment, location, grow_type, grow_size, grow_style, container_size, tags, created_at, updated_at
`

type UpdateGardenParams struct {
	ID            pgtype.UUID
	GroupID       pgtype.UUID
	Name          string
	Comment       string
	Location      string
	GrowType      string
	GrowSize      string
	GrowStyle     string
	ContainerSize string
	Tags          string
	CreatedAt     pgtype.Timestamp
}

func (q *Queries) UpdateGarden(ctx context.Context, arg UpdateGardenParams) (Garden, error) {
	row := q.db.QueryRow(ctx, updateGarden,
		arg.ID,
		arg.GroupID,
		arg.Name,
		arg.Comment,
		arg.Location,
		arg.GrowType,
		arg.GrowSize,
		arg.GrowStyle,
		arg.ContainerSize,
		arg.Tags,
		arg.CreatedAt,
	)
	var i Garden
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.Comment,
		&i.Location,
		&i.GrowType,
		&i.GrowSize,
		&i.GrowStyle,
		&i.ContainerSize,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePlant = `-- name: UpdatePlant :one
UPDATE plants
SET name = $3, comment = $4, notes = $5, grow_cycle_length = $6, parentage = $7, origin = $8, gender = $9, days_flowering = $10, days_cured = $11, harvested_weight = $12, bud_density = $13, bud_pistils = $14, tags = $15, acquired_at=$16, updated_at=CURRENT_TIMESTAMP
WHERE id = $1 AND group_id = $2
RETURNING id, group_id, name, comment, notes, grow_cycle_length, parentage, origin, gender, days_flowering, days_cured, harvested_weight, bud_density, bud_pistils, tags, acquired_at, created_at, updated_at
`

type UpdatePlantParams struct {
	ID              pgtype.UUID
	GroupID         pgtype.UUID
	Name            string
	Comment         string
	Notes           string
	GrowCycleLength string
	Parentage       pgtype.UUID
	Origin          string
	Gender          string
	DaysFlowering   float64
	DaysCured       float64
	HarvestedWeight string
	BudDensity      float64
	BudPistils      bool
	Tags            string
	AcquiredAt      pgtype.Timestamp
}

func (q *Queries) UpdatePlant(ctx context.Context, arg UpdatePlantParams) (Plant, error) {
	row := q.db.QueryRow(ctx, updatePlant,
		arg.ID,
		arg.GroupID,
		arg.Name,
		arg.Comment,
		arg.Notes,
		arg.GrowCycleLength,
		arg.Parentage,
		arg.Origin,
		arg.Gender,
		arg.DaysFlowering,
		arg.DaysCured,
		arg.HarvestedWeight,
		arg.BudDensity,
		arg.BudPistils,
		arg.Tags,
		arg.AcquiredAt,
	)
	var i Plant
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.Comment,
		&i.Notes,
		&i.GrowCycleLength,
		&i.Parentage,
		&i.Origin,
		&i.Gender,
		&i.DaysFlowering,
		&i.DaysCured,
		&i.HarvestedWeight,
		&i.BudDensity,
		&i.BudPistils,
		&i.Tags,
		&i.AcquiredAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateRecipe = `-- name: UpdateRecipe :one
UPDATE recipes
SET name = $3, comment = $4, ingredients = $5, instructions = $6, ph = $7, mix_time_milliseconds = $8, tags = $9, created_at = $10, updated_at=CURRENT_TIMESTAMP
WHERE id = $1 AND group_id = $2
RETURNING id, group_id, name, comment, ingredients, instructions, ph, mix_time_milliseconds, tags, created_at, updated_at
`

type UpdateRecipeParams struct {
	ID                  pgtype.UUID
	GroupID             pgtype.UUID
	Name                string
	Comment             string
	Ingredients         string
	Instructions        string
	Ph                  float64
	MixTimeMilliseconds float64
	Tags                string
	CreatedAt           pgtype.Timestamp
}

func (q *Queries) UpdateRecipe(ctx context.Context, arg UpdateRecipeParams) (Recipe, error) {
	row := q.db.QueryRow(ctx, updateRecipe,
		arg.ID,
		arg.GroupID,
		arg.Name,
		arg.Comment,
		arg.Ingredients,
		arg.Instructions,
		arg.Ph,
		arg.MixTimeMilliseconds,
		arg.Tags,
		arg.CreatedAt,
	)
	var i Recipe
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.Comment,
		&i.Ingredients,
		&i.Instructions,
		&i.Ph,
		&i.MixTimeMilliseconds,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateStrain = `-- name: UpdateStrain :one
UPDATE strains
SET name = $3, comment = $4, notes = $5, type = $6, price = $7, thc_percent = $8, cbd_percent = $9, parentage = $10, aroma = $11, taste = $12, tags = $13, created_at = $14, updated_at=CURRENT_TIMESTAMP
WHERE id = $1 AND group_id = $2
RETURNING id, group_id, name, comment, notes, type, price, thc_percent, cbd_percent, parentage, aroma, taste, tags, created_at, updated_at
`

type UpdateStrainParams struct {
	ID         pgtype.UUID
	GroupID    pgtype.UUID
	Name       string
	Comment    string
	Notes      string
	Type       string
	Price      float64
	ThcPercent float64
	CbdPercent float64
	Parentage  pgtype.UUID
	Aroma      string
	Taste      string
	Tags       string
	CreatedAt  pgtype.Timestamp
}

func (q *Queries) UpdateStrain(ctx context.Context, arg UpdateStrainParams) (Strain, error) {
	row := q.db.QueryRow(ctx, updateStrain,
		arg.ID,
		arg.GroupID,
		arg.Name,
		arg.Comment,
		arg.Notes,
		arg.Type,
		arg.Price,
		arg.ThcPercent,
		arg.CbdPercent,
		arg.Parentage,
		arg.Aroma,
		arg.Taste,
		arg.Tags,
		arg.CreatedAt,
	)
	var i Strain
	err := row.Scan(
		&i.ID,
		&i.GroupID,
		&i.Name,
		&i.Comment,
		&i.Notes,
		&i.Type,
		&i.Price,
		&i.ThcPercent,
		&i.CbdPercent,
		&i.Parentage,
		&i.Aroma,
		&i.Taste,
		&i.Tags,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
