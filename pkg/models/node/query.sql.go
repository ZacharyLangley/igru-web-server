// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: query.sql

package node

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
	"github.com/jackc/pgtype"
)

const addNodeSensor = `-- name: AddNodeSensor :one
INSERT INTO sensors (
  node_id, name, model, category
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, name, node_id, model, category
`

type AddNodeSensorParams struct {
	NodeID   string
	Name     string
	Model    sql.NullString
	Category sql.NullInt32
}

func (q *Queries) AddNodeSensor(ctx context.Context, arg AddNodeSensorParams) (Sensor, error) {
	row := q.db.QueryRow(ctx, addNodeSensor,
		arg.NodeID,
		arg.Name,
		arg.Model,
		arg.Category,
	)
	var i Sensor
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NodeID,
		&i.Model,
		&i.Category,
	)
	return i, err
}

const adoptNode = `-- name: AdoptNode :one
UPDATE nodes
SET owned_by=$2, updated_at=CURRENT_TIMESTAMP, adopted_at=CURRENT_TIMESTAMP
WHERE mac_address=$1
RETURNING mac_address, name, owned_by, custom_labels, created_at, updated_at, adopted_at
`

type AdoptNodeParams struct {
	MacAddress string
	OwnedBy    uuid.NullUUID
}

func (q *Queries) AdoptNode(ctx context.Context, arg AdoptNodeParams) (Node, error) {
	row := q.db.QueryRow(ctx, adoptNode, arg.MacAddress, arg.OwnedBy)
	var i Node
	err := row.Scan(
		&i.MacAddress,
		&i.Name,
		&i.OwnedBy,
		&i.CustomLabels,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AdoptedAt,
	)
	return i, err
}

const createNode = `-- name: CreateNode :one

INSERT INTO nodes (
  mac_address, name, created_at
) VALUES (
  $1, $2, CURRENT_TIMESTAMP
)
RETURNING mac_address, name, owned_by, custom_labels, created_at, updated_at, adopted_at
`

type CreateNodeParams struct {
	MacAddress string
	Name       string
}

// Internal Queries
func (q *Queries) CreateNode(ctx context.Context, arg CreateNodeParams) (Node, error) {
	row := q.db.QueryRow(ctx, createNode, arg.MacAddress, arg.Name)
	var i Node
	err := row.Scan(
		&i.MacAddress,
		&i.Name,
		&i.OwnedBy,
		&i.CustomLabels,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AdoptedAt,
	)
	return i, err
}

const deleteNode = `-- name: DeleteNode :exec
DELETE FROM nodes
WHERE mac_address = $1
`

func (q *Queries) DeleteNode(ctx context.Context, macAddress string) error {
	_, err := q.db.Exec(ctx, deleteNode, macAddress)
	return err
}

const getNode = `-- name: GetNode :one

SELECT mac_address, name, owned_by, custom_labels, created_at, updated_at, adopted_at FROM nodes
WHERE mac_address = $1 LIMIT 1
`

// RPC Queries
func (q *Queries) GetNode(ctx context.Context, macAddress string) (Node, error) {
	row := q.db.QueryRow(ctx, getNode, macAddress)
	var i Node
	err := row.Scan(
		&i.MacAddress,
		&i.Name,
		&i.OwnedBy,
		&i.CustomLabels,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AdoptedAt,
	)
	return i, err
}

const getNodeSensors = `-- name: GetNodeSensors :many
SELECT id, name, node_id, model, category FROM sensors
WHERE node_id = $1
`

func (q *Queries) GetNodeSensors(ctx context.Context, nodeID string) ([]Sensor, error) {
	rows, err := q.db.Query(ctx, getNodeSensors, nodeID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Sensor
	for rows.Next() {
		var i Sensor
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.NodeID,
			&i.Model,
			&i.Category,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNodes = `-- name: GetNodes :many
SELECT mac_address, name, owned_by, custom_labels, created_at, updated_at, adopted_at FROM nodes
WHERE owned_by = $1 LIMIT $2 OFFSET $3
`

type GetNodesParams struct {
	OwnedBy uuid.NullUUID
	Limit   int32
	Offset  int32
}

func (q *Queries) GetNodes(ctx context.Context, arg GetNodesParams) ([]Node, error) {
	rows, err := q.db.Query(ctx, getNodes, arg.OwnedBy, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Node
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.MacAddress,
			&i.Name,
			&i.OwnedBy,
			&i.CustomLabels,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AdoptedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUnadoptedNodes = `-- name: GetUnadoptedNodes :many
SELECT mac_address, name, owned_by, custom_labels, created_at, updated_at, adopted_at FROM nodes
WHERE owned_by IS NULL LIMIT $1 OFFSET $2
`

type GetUnadoptedNodesParams struct {
	Limit  int32
	Offset int32
}

func (q *Queries) GetUnadoptedNodes(ctx context.Context, arg GetUnadoptedNodesParams) ([]Node, error) {
	rows, err := q.db.Query(ctx, getUnadoptedNodes, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Node
	for rows.Next() {
		var i Node
		if err := rows.Scan(
			&i.MacAddress,
			&i.Name,
			&i.OwnedBy,
			&i.CustomLabels,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.AdoptedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const unadoptNode = `-- name: UnadoptNode :one
UPDATE nodes
SET owned_by=NULL, updated_at=CURRENT_TIMESTAMP, adopted_at=NULL
WHERE mac_address=$1
RETURNING mac_address, name, owned_by, custom_labels, created_at, updated_at, adopted_at
`

func (q *Queries) UnadoptNode(ctx context.Context, macAddress string) (Node, error) {
	row := q.db.QueryRow(ctx, unadoptNode, macAddress)
	var i Node
	err := row.Scan(
		&i.MacAddress,
		&i.Name,
		&i.OwnedBy,
		&i.CustomLabels,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AdoptedAt,
	)
	return i, err
}

const updateNode = `-- name: UpdateNode :one
UPDATE nodes
SET name=$2, custom_labels=$3, updated_at=CURRENT_TIMESTAMP
WHERE mac_address=$1
RETURNING mac_address, name, owned_by, custom_labels, created_at, updated_at, adopted_at
`

type UpdateNodeParams struct {
	MacAddress   string
	Name         string
	CustomLabels pgtype.JSONB
}

func (q *Queries) UpdateNode(ctx context.Context, arg UpdateNodeParams) (Node, error) {
	row := q.db.QueryRow(ctx, updateNode, arg.MacAddress, arg.Name, arg.CustomLabels)
	var i Node
	err := row.Scan(
		&i.MacAddress,
		&i.Name,
		&i.OwnedBy,
		&i.CustomLabels,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.AdoptedAt,
	)
	return i, err
}

const updateNodeSensor = `-- name: UpdateNodeSensor :one
UPDATE sensors
SET name=$2, model=$3, category=$4
WHERE node_id=$1
RETURNING id, name, node_id, model, category
`

type UpdateNodeSensorParams struct {
	NodeID   string
	Name     string
	Model    sql.NullString
	Category sql.NullInt32
}

func (q *Queries) UpdateNodeSensor(ctx context.Context, arg UpdateNodeSensorParams) (Sensor, error) {
	row := q.db.QueryRow(ctx, updateNodeSensor,
		arg.NodeID,
		arg.Name,
		arg.Model,
		arg.Category,
	)
	var i Sensor
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.NodeID,
		&i.Model,
		&i.Category,
	)
	return i, err
}
